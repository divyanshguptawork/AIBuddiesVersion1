import Foundation
// Assuming OAuthManager is a separate file that handles authentication
// import AppAuth // Not directly used by GoogleCalendarAPI, only OAuthManager
// import GTMAppAuth // Not directly used by GoogleCalendarAPI
// import GTMSessionFetcher // Not directly used by GoogleCalendarAPI

// MARK: - Google Calendar API Models

// Represents a Google Calendar event
struct GoogleCalendarEvent: Codable {
    var id: String? // Event ID, generated by Google Calendar
    let summary: String // Title of the event
    let description: String?
    let location: String?
    let start: EventDateTime
    let end: EventDateTime
    let recurrence: [String]? // Optional recurrence rules (e.g., ["RRULE:FREQ=DAILY;COUNT=2"])
    let attendees: [EventAttendee]? // Optional attendees

    // Nested struct for start/end times
    struct EventDateTime: Codable {
        let dateTime: String? // ISO 8601 format (e.g., "2025-07-20T10:00:00-07:00")
        let date: String?     // YYYY-MM-DD for all-day events (e.g., "2025-07-20")
        let timeZone: String? // e.g., "America/Los_Angeles"

        // Custom initializer to handle either dateTime or date
        init(dateTime: Date, timeZone: TimeZone = .current) {
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds, .withTimeZone]
            self.dateTime = formatter.string(from: dateTime)
            self.date = nil
            self.timeZone = timeZone.identifier
        }

        init(date: Date) { // For all-day events
            let formatter = DateFormatter()
            formatter.dateFormat = "yyyy-MM-dd"
            self.date = formatter.string(from: date)
            self.dateTime = nil
            self.timeZone = nil // All-day events don't typically have a timezone on the date field itself
        }
    }

    // Nested struct for attendees
    struct EventAttendee: Codable {
        let email: String
    }
}

// Helper struct to decode Google Calendar List Events API response
struct GoogleCalendarListEventsResponse: Codable {
    let kind: String
    let etag: String
    let summary: String
    let updated: String
    let timeZone: String
    let accessRole: String
    let defaultReminders: [GoogleCalendarDefaultReminder]
    let nextSyncToken: String?
    let items: [GoogleCalendarEvent]? // Array of events
}

// Helper struct for default reminders (part of calendar metadata)
struct GoogleCalendarDefaultReminder: Codable {
    let method: String
    let minutes: Int
}

// MARK: - AnyCodable Helper (for flexible JSON decoding)
// This helper allows decoding JSON into a dictionary where values can be of any Codable type.
// Useful for inspecting raw JSON or handling varied error response structures.
struct AnyCodable: Codable {
    let value: Any

    init(_ value: Any) {
        self.value = value
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let bool = try? container.decode(Bool.self) {
            self.value = bool
        } else if let int = try? container.decode(Int.self) {
            self.value = int
        } else if let double = try? container.decode(Double.self) {
            self.value = double
        } else if let string = try? container.decode(String.self) {
            self.value = string
        } else if container.decodeNil() {
            self.value = ()
        } else if let array = try? container.decode([AnyCodable].self) { // FIX: Corrected decode call
            self.value = array.map { $0.value }
        } else if let dictionary = try? container.decode([String: AnyCodable].self) { // FIX: Corrected decode call
            self.value = dictionary.mapValues { $0.value }
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "AnyCodable cannot decode value")
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        if let bool = value as? Bool {
            try container.encode(bool)
        } else if let int = value as? Int {
            try container.encode(int)
        } else if let double = value as? Double {
            try container.encode(double)
        } else if let string = value as? String {
            try container.encode(string)
        } else if value is Void {
            try container.encodeNil()
        } else if let array = value as? [Any] {
            try container.encode(array.map(AnyCodable.init))
        } else if let dictionary = value as? [String: Any] {
            try container.encode(dictionary.mapValues(AnyCodable.init))
        } else {
            let context = EncodingError.Context(codingPath: container.codingPath, debugDescription: "AnyCodable cannot encode value")
            throw EncodingError.invalidValue(value, context)
        }
    }
}

// Removed the duplicate OAuthError enum definition.
// It is now defined in OAuthManager.swift and used from there.


// MARK: - GoogleCalendarAPI Class

class GoogleCalendarAPI {
    static let shared = GoogleCalendarAPI()

    private let baseURL = "https://www.googleapis.com/calendar/v3/calendars/primary" // Primary calendar for the authenticated user

    private init() {}

    /// Fetches events from the user's primary Google Calendar.
    /// - Parameters:
    ///   - startDate: The start date for the event range (inclusive).
    ///   - endDate: The end date for the event range (exclusive).
    ///   - completion: A closure that returns an array of GoogleCalendarEvent or an Error.
    func fetchEvents(startDate: Date, endDate: Date, completion: @escaping ([GoogleCalendarEvent]?, Error?) -> Void) {
        // Use the updated getAccessToken method from OAuthManager
        OAuthManager.shared.getAccessToken { [weak self] token, error in
            guard let self = self else { return }

            if let error = error {
                completion(nil, error)
                return
            }
            guard let accessToken = token else {
                completion(nil, OAuthError.notAuthorized("Google Calendar: Access token not available."))
                return
            }

            let dateFormatter = ISO8601DateFormatter()
            dateFormatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]

            guard let encodedMinTime = dateFormatter.string(from: startDate).addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed),
                  let encodedMaxTime = dateFormatter.string(from: endDate).addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) else {
                completion(nil, OAuthError.invalidConfiguration("Invalid date encoding for URL."))
                return
            }

            // Construct the URL for listing events
            // timeMin and timeMax should be in RFC3339 format (ISO 8601)
            var urlComponents = URLComponents(string: "\(self.baseURL)/events")!
            urlComponents.queryItems = [
                URLQueryItem(name: "timeMin", value: encodedMinTime),
                URLQueryItem(name: "timeMax", value: encodedMaxTime),
                URLQueryItem(name: "singleEvents", value: "true"), // Expand recurring events
                URLQueryItem(name: "orderBy", value: "startTime")
            ]

            guard let url = urlComponents.url else {
                completion(nil, OAuthError.invalidConfiguration("Invalid URL for fetching events."))
                return
            }

            var request = URLRequest(url: url)
            request.addValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")

            URLSession.shared.dataTask(with: request) { data, response, error in
                DispatchQueue.main.async {
                    if let error = error {
                        completion(nil, error)
                        return
                    }
                    guard let data = data else {
                        completion(nil, OAuthError.noDataReceived("No data received from Google Calendar API."))
                        return
                    }

                    do {
                        let decoder = JSONDecoder()
                        // Check for API errors first
                        if let httpResponse = response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {
                            let errorResponse = try? decoder.decode([String: AnyCodable].self, from: data) // Try to decode error response
                            let errorMessage = errorResponse?["error"]?.value as? String ?? "Unknown Google Calendar API error"
                            completion(nil, OAuthError.apiError("Google Calendar API Error \(httpResponse.statusCode): \(errorMessage)"))
                            return
                        }

                        let eventsResponse = try decoder.decode(GoogleCalendarListEventsResponse.self, from: data)
                        completion(eventsResponse.items, nil)

                    } catch {
                        print("GoogleCalendarAPI: Error decoding events: \(error.localizedDescription)")
                        completion(nil, OAuthError.jsonDecodingError(error))
                    }
                }
            }.resume()
        }
    }

    /// Adds an event to the user's primary Google Calendar.
    /// - Parameters:
    ///   - title: The title of the event.
    ///   - startDate: The start date and time of the event.
    ///   - endDate: The end date and time of the event.
    ///   - location: Optional location string.
    ///   - description: Optional description string.
    ///   - completion: A closure that returns the added GoogleCalendarEvent or an Error.
    func addEvent(title: String, startDate: Date, endDate: Date, location: String?, description: String?, completion: @escaping (GoogleCalendarEvent?, Error?) -> Void) {
        // Use the updated getAccessToken method from OAuthManager
        OAuthManager.shared.getAccessToken { [weak self] token, error in
            guard let self = self else { return }

            if let error = error {
                completion(nil, error)
                return
            }
            guard let accessToken = token else {
                completion(nil, OAuthError.notAuthorized("Google Calendar: Access token not available."))
                return
            }

            // Determine timezone for the event
            let timeZoneIdentifier = TimeZone.current.identifier

            let event = GoogleCalendarEvent(
                summary: title,
                description: description,
                location: location,
                start: GoogleCalendarEvent.EventDateTime(dateTime: startDate, timeZone: TimeZone(identifier: timeZoneIdentifier)!),
                end: GoogleCalendarEvent.EventDateTime(dateTime: endDate, timeZone: TimeZone(identifier: timeZoneIdentifier)!),
                recurrence: nil, // Not handling recurrence for now
                attendees: nil    // Not handling attendees for now
            )

            guard let uploadData = try? JSONEncoder().encode(event) else {
                // Corrected: OAuthError now has .jsonEncodingError
                completion(nil, OAuthError.jsonEncodingError(NSError(domain: "GoogleCalendarAPI", code: 0, userInfo: [NSLocalizedDescriptionKey: "Failed to encode event data."])))
                return
            }

            let url = URL(string: "\(self.baseURL)/events")!
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.addValue("Bearer \(accessToken)", forHTTPHeaderField: "Authorization")
            request.addValue("application/json", forHTTPHeaderField: "Content-Type")
            request.httpBody = uploadData

            URLSession.shared.dataTask(with: request) { data, response, error in
                DispatchQueue.main.async {
                    if let error = error {
                        completion(nil, error)
                        return
                    }
                    guard let data = data else {
                        completion(nil, OAuthError.noDataReceived("No data received from Google Calendar API."))
                        return
                    }

                    do {
                        let decoder = JSONDecoder()
                        // Check for API errors first
                        if let httpResponse = response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {
                            let errorResponse = try? decoder.decode([String: AnyCodable].self, from: data) // Try to decode error response
                            let errorMessage = (errorResponse?["error"]?.value as? [String: AnyCodable])?["message"]?.value as? String ?? "Unknown Google Calendar API error"
                            completion(nil, OAuthError.apiError("Google Calendar API Error \(httpResponse.statusCode): \(errorMessage)"))
                            return
                        }

                        let addedEvent = try decoder.decode(GoogleCalendarEvent.self, from: data)
                        completion(addedEvent, nil)

                    } catch {
                        print("GoogleCalendarAPI: Error decoding added event response: \(error.localizedDescription)")
                        completion(nil, OAuthError.jsonDecodingError(error))
                    }
                }
            }.resume()
        }
    }
}
